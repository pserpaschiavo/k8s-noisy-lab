#!/bin/bash

# Importar logger
source "$(dirname "$0")/logger.sh"

# Queries PromQL para coleta de métricas (séries temporais)
declare -A PROM_QUERIES=(
    # Métricas existentes de recursos
    ["cpu_usage"]="sum(rate(container_cpu_usage_seconds_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m])) by (namespace)"
    ["cpu_throttled_time"]="sum(rate(container_cpu_cfs_throttled_seconds_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m])) by (namespace)"
    ["cpu_throttled_ratio"]="sum(rate(container_cpu_cfs_throttled_seconds_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m])) / sum(rate(container_cpu_cfs_periods_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]))"
    ["memory_usage"]="sum(container_memory_working_set_bytes{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}) by (namespace)"
    ["oom_kills"]="sum(increase(container_oom_events_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[5m])) by (namespace)"
    ["network_transmit"]="sum(rate(container_network_transmit_bytes_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m])) by (namespace)"
    ["network_receive"]="sum(rate(container_network_receive_bytes_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m])) by (namespace)"
    ["network_dropped"]="sum(rate(container_network_receive_packets_dropped_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m])) by (namespace)"
    
    # Métricas básicas do NGINX Ingress Controller
    ["nginx_connections"]="sum(nginx_ingress_controller_nginx_process_connections{namespace=~\"ingress-nginx\",state=~\"active|reading|writing|waiting\"}) by (state)"
    ["nginx_connections_total"]="sum(rate(nginx_ingress_controller_nginx_process_connections_total{namespace=~\"ingress-nginx\"}[1m])) by (state)"
    ["nginx_cpu_usage"]="rate(nginx_ingress_controller_nginx_process_cpu_seconds_total{namespace=~\"ingress-nginx\"}[1m])"
    ["nginx_memory_usage"]="nginx_ingress_controller_nginx_process_resident_memory_bytes{namespace=~\"ingress-nginx\"}"
    ["nginx_requests_total"]="rate(nginx_ingress_controller_nginx_process_requests_total{namespace=~\"ingress-nginx\"}[1m])"
    ["nginx_bytes_read"]="rate(nginx_ingress_controller_nginx_process_read_bytes_total{namespace=~\"ingress-nginx\"}[1m])"
    ["nginx_bytes_written"]="rate(nginx_ingress_controller_nginx_process_write_bytes_total{namespace=~\"ingress-nginx\"}[1m])"
    
    # Outras métricas de cluster
    ["pod_restarts"]="increase(kube_pod_container_status_restarts_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[5m])"
    ["pod_ready_age"]="time() - kube_pod_status_ready{condition=\"true\",namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}"
    
    # Métricas de latência (baseadas na análise do tempo de processamento)
    ["latency_process_time"]="rate(nginx_ingress_controller_nginx_process_cpu_seconds_total{namespace=~\"ingress-nginx\"}[1m]) / rate(nginx_ingress_controller_nginx_process_connections_total{namespace=~\"ingress-nginx\",state=\"handled\"}[1m])"
    ["latency_bytes_per_request"]="rate(nginx_ingress_controller_nginx_process_read_bytes_total{namespace=~\"ingress-nginx\"}[1m]) / rate(nginx_ingress_controller_nginx_process_requests_total{namespace=~\"ingress-nginx\"}[1m])"
    
    # Métricas de jitter (variação nas métricas de processamento)
    ["jitter_admission_process"]="stddev_over_time(nginx_ingress_controller_admission_roundtrip_duration{namespace=\"ingress-nginx\"}[5m])"
    ["jitter_processing_rate"]="stddev_over_time(rate(nginx_ingress_controller_nginx_process_cpu_seconds_total{namespace=\"ingress-nginx\"}[1m])[5m:1m])"
    
    # Métricas de correlação para análise de noisy neighbor
    ["correlation_cpu_latency"]="sum(rate(container_cpu_usage_seconds_total{namespace=\"tenant-b\"}[1m])) / on() group_left() (rate(nginx_ingress_controller_nginx_process_cpu_seconds_total{namespace=\"ingress-nginx\"}[1m]) / rate(nginx_ingress_controller_nginx_process_requests_total{namespace=\"ingress-nginx\"}[1m]))"
    ["correlation_memory_latency"]="sum(container_memory_working_set_bytes{namespace=\"tenant-b\"}) / on() group_left() (rate(nginx_ingress_controller_nginx_process_cpu_seconds_total{namespace=\"ingress-nginx\"}[1m]) / rate(nginx_ingress_controller_nginx_process_requests_total{namespace=\"ingress-nginx\"}[1m]))"
    
    # Métricas comparativas entre tenants (referência vs. vítima)
    ["tenant_latency_comparison"]="avg(rate(container_cpu_usage_seconds_total{namespace=\"tenant-a\"}[1m]) / rate(container_network_receive_packets_total{namespace=\"tenant-a\"}[1m])) / avg(rate(container_cpu_usage_seconds_total{namespace=\"tenant-c\"}[1m]) / rate(container_network_receive_packets_total{namespace=\"tenant-c\"}[1m]))"
    ["tenant_jitter"]="stddev_over_time((rate(container_network_receive_packets_total{namespace=~\"tenant-a|tenant-c|tenant-d\"}[1m]) / rate(container_network_receive_bytes_total{namespace=~\"tenant-a|tenant-c|tenant-d\"}[1m]))[5m:1m])"
    
    # MÉTRICAS AVANÇADAS DE CPU
    ["cpu_usage_variability"]="stddev_over_time(sum by (namespace) (rate(container_cpu_usage_seconds_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]))[5m:])"
    ["cpu_usage_pct_of_limit"]="sum by (namespace) (rate(container_cpu_usage_seconds_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]) * 100) / sum by (namespace) (kube_pod_container_resource_limits{resource=\"cpu\", namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"})"
    
    # MÉTRICAS AVANÇADAS DE MEMÓRIA
    ["memory_pressure"]="sum by (namespace) (container_memory_working_set_bytes{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}) / sum by (namespace) (container_spec_memory_limit_bytes{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"})"
    ["memory_growth_rate"]="deriv(sum by (namespace) (container_memory_working_set_bytes{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"})[10m:])"
    ["memory_oomkill_events"]="sum by (namespace) (kube_pod_container_status_last_terminated_reason{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\", reason=\"OOMKilled\"})"
    
    # MÉTRICAS AVANÇADAS DE REDE
    ["network_total_bandwidth"]="sum by (namespace) (rate(container_network_receive_bytes_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]) + rate(container_network_transmit_bytes_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]))"
    ["network_packet_rate"]="sum by (namespace) (rate(container_network_receive_packets_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]) + rate(container_network_transmit_packets_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]))"
    ["network_error_rate"]="sum by (namespace) (rate(container_network_receive_errors_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]) + rate(container_network_transmit_errors_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]))"
    ["network_efficiency"]="sum by (namespace) (rate(container_network_transmit_bytes_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m])) / sum by (namespace) (rate(container_network_transmit_packets_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]))"
    
    # MÉTRICAS AVANÇADAS DE DISCO
    ["disk_io_total"]="sum by (namespace) (rate(container_fs_reads_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]) + rate(container_fs_writes_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]))"
    ["disk_throughput_total"]="sum by (namespace) (rate(container_fs_reads_bytes_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]) + rate(container_fs_writes_bytes_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]))"
    ["disk_avg_io_size"]="sum by (namespace) (rate(container_fs_reads_bytes_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]) + rate(container_fs_writes_bytes_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m])) / sum by (namespace) (rate(container_fs_reads_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]) + rate(container_fs_writes_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]))"
    
    # MÉTRICAS COMBINADAS E RELAÇÕES ENTRE TENANTS (TENANT-C - SENSÍVEL À MEMÓRIA)
    ["cpu_usage_noisy_victim_ratio"]="sum(rate(container_cpu_usage_seconds_total{namespace=\"tenant-b\"}[1m])) / sum(rate(container_cpu_usage_seconds_total{namespace=\"tenant-c\"}[1m]))"
    ["memory_usage_noisy_victim_ratio"]="sum(container_memory_working_set_bytes{namespace=\"tenant-b\"}) / sum(container_memory_working_set_bytes{namespace=\"tenant-c\"})"
    ["network_usage_noisy_victim_ratio"]="sum(rate(container_network_transmit_bytes_total{namespace=\"tenant-b\"}[1m]) + rate(container_network_receive_bytes_total{namespace=\"tenant-b\"}[1m])) / sum(rate(container_network_transmit_bytes_total{namespace=\"tenant-c\"}[1m]) + rate(container_network_receive_bytes_total{namespace=\"tenant-c\"}[1m]))"
    ["resource_dominance_index"]="(sum(rate(container_cpu_usage_seconds_total{namespace=\"tenant-b\"}[1m])) / sum(rate(container_cpu_usage_seconds_total{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}[1m]))) * (sum(container_memory_working_set_bytes{namespace=\"tenant-b\"}) / sum(container_memory_working_set_bytes{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}))"
    
    # NOVAS MÉTRICAS DE RELAÇÃO ENTRE TENANT-B (BARULHENTO) E TENANT-A (SENSÍVEL À REDE)
    ["cpu_usage_noisy_network_ratio"]="sum(rate(container_cpu_usage_seconds_total{namespace=\"tenant-b\"}[1m])) / sum(rate(container_cpu_usage_seconds_total{namespace=\"tenant-a\"}[1m]))"
    ["memory_usage_noisy_network_ratio"]="sum(container_memory_working_set_bytes{namespace=\"tenant-b\"}) / sum(container_memory_working_set_bytes{namespace=\"tenant-a\"})"
    ["network_usage_noisy_network_ratio"]="sum(rate(container_network_transmit_bytes_total{namespace=\"tenant-b\"}[1m]) + rate(container_network_receive_bytes_total{namespace=\"tenant-b\"}[1m])) / sum(rate(container_network_transmit_bytes_total{namespace=\"tenant-a\"}[1m]) + rate(container_network_receive_bytes_total{namespace=\"tenant-a\"}[1m]))"
    ["network_packets_noisy_network_ratio"]="sum(rate(container_network_transmit_packets_total{namespace=\"tenant-b\"}[1m]) + rate(container_network_receive_packets_total{namespace=\"tenant-b\"}[1m])) / sum(rate(container_network_transmit_packets_total{namespace=\"tenant-a\"}[1m]) + rate(container_network_receive_packets_total{namespace=\"tenant-a\"}[1m]))"
    ["network_dropped_noisy_network_ratio"]="sum(rate(container_network_receive_packets_dropped_total{namespace=\"tenant-b\"}[1m]) + rate(container_network_transmit_packets_dropped_total{namespace=\"tenant-b\"}[1m])) / (sum(rate(container_network_receive_packets_dropped_total{namespace=\"tenant-a\"}[1m]) + rate(container_network_transmit_packets_dropped_total{namespace=\"tenant-a\"}[1m])) + 1)"
    
    # MÉTRICAS DE SAÚDE DO CLUSTER
    ["pod_readiness_ratio"]="sum by (namespace) (kube_pod_status_ready{condition=\"true\",namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"}) / count by (namespace) (kube_pod_info{namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"})"
    ["pending_pods"]="sum by (namespace) (kube_pod_status_phase{phase=\"Pending\",namespace=~\"tenant-a|tenant-b|tenant-c|tenant-d\"})"
    
    # MÉTRICAS ESPECÍFICAS PARA MONITORAR TENANT-D (CPU E DISCO)
    ["postgres_disk_io"]="sum(rate(pg_stat_database_blks_read{namespace=\"tenant-d\"}[1m]) + rate(pg_stat_database_blks_written{namespace=\"tenant-d\"}[1m])) by (datname)"
    ["postgres_connections"]="sum(pg_stat_database_numbackends{namespace=\"tenant-d\"}) by (datname)"
    ["postgres_transactions"]="sum(rate(pg_stat_database_xact_commit{namespace=\"tenant-d\"}[1m]) + rate(pg_stat_database_xact_rollback{namespace=\"tenant-d\"}[1m])) by (datname)"
    ["postgres_query_time"]="sum(pg_stat_statements_mean_exec_time{namespace=\"tenant-d\"}) by (query)"
    ["disk_io_tenant_d"]="sum(rate(container_fs_reads_bytes_total{namespace=\"tenant-d\"}[1m]) + rate(container_fs_writes_bytes_total{namespace=\"tenant-d\"}[1m])) by (container)"
    ["cpu_tenant_d_vs_other_ratio"]="sum(rate(container_cpu_usage_seconds_total{namespace=\"tenant-d\"}[1m])) / sum(rate(container_cpu_usage_seconds_total{namespace=~\"tenant-a|tenant-b|tenant-c\"}[1m]))"
    ["disk_tenant_d_vs_other_ratio"]="sum(rate(container_fs_reads_bytes_total{namespace=\"tenant-d\"}[1m]) + rate(container_fs_writes_bytes_total{namespace=\"tenant-d\"}[1m])) / sum(rate(container_fs_reads_bytes_total{namespace=~\"tenant-a|tenant-b|tenant-c\"}[1m]) + rate(container_fs_writes_bytes_total{namespace=~\"tenant-a|tenant-b|tenant-c\"}[1m]))"
)

# Variável para armazenar o PID do processo de coleta de métricas
METRICS_PID=""

# Função de coleta contínua com logs de erro e fallback de label
collect_metrics_continuously() {
    local phase_id="$1" round_num="$2" metrics_dir="$3"
    while true; do
        local ts=$(date +%Y%m%d_%H%M%S)
        for name in "${!PROM_QUERIES[@]}"; do
            local query="${PROM_QUERIES[$name]}"
            # Chama API Prometheus
            local resp
            if ! resp=$(curl -s --connect-timeout 5 "http://localhost:9090/api/v1/query?query=$(printf '%s' "$query" | jq -sRr @uri)"); then
                echo "[$ts] ERROR: curl failed for $name" >> "$LOG_FILE"
                continue
            fi
            # Extrai namespace e valor, cada linha CSV: ns,val
            local csv_lines
            csv_lines=$(echo "$resp" | jq -r '.data.result[]? | [(.metric.namespace // .metric.pod // .metric.instance // "unknown"), (.value[1] // "")] | @csv')
            if [ -z "$csv_lines" ]; then
                echo "[$ts] WARN: no data for $name" >> "$LOG_FILE"
                continue
            fi
            # Grava cada linha em CSV por namespace
            while IFS=',' read -r ns val; do
                ns=${ns//\"/}
                val=${val//\"/}
                local out_dir="$metrics_dir/round-${round_num}/${phase_id}/${ns}"
                mkdir -p "$out_dir"
                local file="$out_dir/${name}.csv"
                if [ ! -f "$file" ]; then
                    echo "timestamp,value" > "$file"
                fi
                echo "\"${ts}\",\"${val}\"" >> "$file"
            done <<< "$csv_lines"
        done
        sleep 5
    done
}

# Função para iniciar a coleta contínua
start_collecting_metrics() {
    local phase="$1"
    local round="$2"
    local metrics_dir="$3"
    local collect_metrics="$4"
    
    if [ "$collect_metrics" = true ]; then
        collect_metrics_continuously "$phase" "$round" "$metrics_dir" &
        METRICS_PID=$!
        log "$BLUE" "Coleta de métricas iniciada com PID: $METRICS_PID"
    else
        log "$YELLOW" "Coleta de métricas desativada"
    fi
}

# Função para interromper a coleta
stop_collecting_metrics() {
    if [ -n "$METRICS_PID" ] && kill -0 $METRICS_PID 2>/dev/null; then
        log "$BLUE" "Interrompendo coleta de métricas (PID: $METRICS_PID)..."
        kill $METRICS_PID
        wait $METRICS_PID 2>/dev/null || true
        log "$BLUE" "Coleta de métricas finalizada."
    fi
    unset METRICS_PID
}